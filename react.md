[Вопросы для собеседования](README.md)

# React Core

+ [Что такое React?](#Что-такое-React)
+ [Что такое Виртуальный DOM?](#Что-такое-Виртуальный-DOM?)
+ [Какие методы жизненного цикла компонента существуют в React?](#Какие-методы-жизненного-цикла-компонента-существуют-в-React?)
+ [Что такое Context в React и для чего он используется?](#Что-такое-Context-в-React-и-для-чего-он-используется?)
+ [Для чего нужен атрибут key при рендере списков?](#Для-чего-нужен-атрибут-key-при-рендере-списков?)
+ [Как работает проп children?](#Как-работает-проп-children?)
+ [В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?](#В-чем-разница-между-управляемыми-(controlled)-и-неуправляемыми-(uncontrolled)-компонентами?)
+ [Что такое PureComponent?](#Что-такое-PureComponent?)
+ [Что такое Компонент высшего порядка (Higher-Order Component, HOC)?](#Что-такое-Компонент-высшего-порядка-(Higher-Order-Component,-HOC)?)
+ [Что такое хуки в React?](#Что-такое-хуки-в-React?)
+ [Что такое порталы в React?](#Что-такое-порталы-в-React?)
+ [Что такое React Reconciliation (Cверка) и как он работает?](#Что-такое-React-Reconciliation-(Cверка)-и-как-он-работает?)
+ [Как выполнить рендеринг элементов массива?](#Как-выполнить-рендеринг-элементов-массива?)
+ [Чем управляемые компоненты отличаются от неуправляемых?](#Чем-управляемые-компоненты-отличаются-от-неуправляемых?)
+ [В чем разница между классовыми и функциональными компонентами?](#В-чем-разница-между-классовыми-и-функциональными-компонентами?)
+ [Что такое методы жизненного цикла компонента?](#Что-такое-методы-жизненного-цикла-компонента?)
+ [В чем заключаются особенности использования useState?](#В-чем-заключаются-особенности-использования-useState?)
+ [В чем заключаются особенности использования useEffect?](#В-чем-заключаются-особенности-использования-useEffect?)
+ [Как отследить размонтирование функционального компонента?](#Как-отследить-размонтирование-функционального-компонента?)
+ [Что такое реквизиты(props, пропсы) в React?](#Что-такое-реквизиты(props,-пропсы)-в-React?)
+ [Что такое менеджер состояний и с какими из них вы работали?](#Что-такое-менеджер-состояний-и-с-какими-из-них-вы-работали?)
+ [В каких случаях можно использовать локальное состояние, а когда следует использовать глобальное состояние?](#В-каких-случаях-можно-использовать-локальное-состояние,-а-когда-следует-использовать-глобальное-состояние?)
+ [Что такое пробрасывание пропсов (props drilling)?](#Что-такое-пробрасывание-пропсов-(props-drilling)?)
+ [Как работает условный рендеринг элементов?](#Как-работает-условный-рендеринг-элементов?)
+ [Для чего и как используется UseMemo?](#Для-чего-и-как-используется-UseMemo?)
+ [Для чего используется useCallback и как он работает?](#Для-чего-используется-useCallback-и-как-он-работает?)
+ [В чем разница между useMemo и useCallback?](#В-чем-разница-между-useMemo-и-useCallback?)
+ [Как используют React Context?](#Как-используют-React-Context?)
+ [Для чего используется useContext и как он работает?](#Для-чего-используется-useContext-и-как-он-работает?)
+ [Для чего используется useRef и как он работает?](#Для-чего-используется-useRef-и-как-он-работает?)
+ [Что такое React.memo()?](#Что-такое-React.memo()?)
+ [Что такое фрагмент React?](#Что-такое-фрагмент-React?)
+ [Что такое React Reconciliation?](#Что-такое-React-Reconciliation?)
+ [Зачем нужны ключи в списках при использовании map()?](#Зачем-нужны-ключи-в-списках-при-использовании-map()?)
+ [Как отследить изменения поля объекта в функциональном компоненте?](#Как-отследить-изменения-поля-объекта-в-функциональном-компоненте?)
+ [Как получить доступ к элементу DOM?](#Как-получить-доступ-к-элементу-DOM?)
+ [Что такое пользовательский хук?](#Что-такое-пользовательский-хук?)
+ [Что такое публичный API?](#Что-такое-публичный-API?)
+ [Перечислите правила создания пользовательского хука.](#Перечислите-правила-создания-пользовательского-хука.)
+ [Что такое серверный рендеринг (Server-Side Rendering)?](#Что-такое-серверный-рендеринг-(Server-Side-Rendering)?)
+ [Перечислите преимущества серверного рендеринга.](#Перечислите-преимущества-серверного-рендеринга.)


## Что такое React?

<details> 
  <summary>Правильный ответ</summary>

React - это библиотека JavaScript, разработанная компанией Facebook, которая используется для создания пользовательских интерфейсов. Она позволяет разбивать пользовательский интерфейс на небольшие компоненты, которые могут обновляться независимо друг от друга, что обеспечивает эффективное управление состоянием и обновлениями на веб-странице.  
React использует виртуальное DOM (Document Object Model) для оптимизации производительности, позволяя эффективно обновлять только изменившиеся части интерфейса. Одной из главных концепций React является "однонаправленный поток данных", который облегчает отслеживание изменений и управление состоянием приложения. React широко используется в разработке веб-приложений и мобильных приложений с использованием фреймворка React Native.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое Виртуальный DOM?

<details> 
  <summary>Правильный ответ</summary>

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.

</details>

[Вернуться в меню React Core](#react-core)

## Какие методы жизненного цикла компонента существуют в React?

<details> 
  <summary>Правильный ответ</summary>

- **render()** — единственный обязательный метод в классовом компоненте.
При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null

- **constructor()** - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().

- **componentDidMount()** - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().

- **componentDidUpdate(prevProps, prevState, snapshot)** - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.

- **componentWillUnmount()** - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

- **componentDidCatch(error, info)** - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.

- **shouldComponentUpdate(nextProps, nextState)** - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

- **static getDerivedStateFromProps(props, state)** - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.

- **getSnapshotBeforeUpdate(prevProps, prevState)** - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().

- **static getDerivedStateFromError(error)** - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().

![Пример](https://camo.githubusercontent.com/f082e1cbe7fcf46b5f8c5f2c2c0ae3f09d9513f2c6faa42c904c81d76d71b5c4/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a6350777655685a726e423164745a6e6a4245665866412e706e67)

</details>

[Вернуться в меню React Core](#react-core)

## Что такое Context в React и для чего он используется?

<details> 
  <summary>Правильный ответ</summary>

Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).

Контекст позволяет избежать передачи пропсов в промежуточные компоненты:
```javascript
// Контекст позволяет передавать значение глубоко
// в дерево компонентов без явной передачи пропсов
// на каждом уровне. Создадим контекст для текущей
// UI-темы (со значением "light" по умолчанию).
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    // Компонент Provider используется для передачи текущей
    // UI-темы вниз по дереву. Любой компонент может использовать
    // этот контекст и не важно, как глубоко он находится.
    // В этом примере мы передаём "dark" в качестве значения контекста.
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// Компонент, который находится в середине,
// теперь не должен явно передавать UI-тему вниз.
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // Определяем contextType, чтобы получить значение контекста.
  // React найдёт (выше по дереву) ближайший Provider-компонент,
  // предоставляющий этот контекст, и использует его значение.
  // В этом примере значение UI-темы будет "dark".
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
```
Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.

  **API:**  
- **React.createContext** - Создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
- **Context.Provider** - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.  
- **Class.contextType** - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.  
- **Context.Consumer** - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().

</details>

[Вернуться в меню React Core](#react-core)

## Для чего нужен атрибут key при рендере списков?

<details> 
  <summary>Правильный ответ</summary>

Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.

</details>

[Вернуться в меню React Core](#react-core)

##  Как работает проп children?

<details> 
  <summary>Правильный ответ</summary>
  
Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
```javascript
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}
```
Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
```javascript
function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Добро пожаловать
      </h1>
      <p className="Dialog-message">
        Спасибо, что посетили наш космический корабль!
      </p>
    </FancyBorder>
  );
}
```
Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.

</details>

[Вернуться в меню React Core](#react-core)

## В чем разница между управляемыми (controlled) и неуправляемыми (uncontrolled) компонентами?

<details> 
  <summary>Правильный ответ</summary>

В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().

В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:
```javascript
handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
```
Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Имя:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}
```
Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое PureComponent?

<details> 
  <summary>Правильный ответ</summary>

React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.

Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.

Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое Компонент высшего порядка (Higher-Order Component, HOC)?

<details> 
  <summary>Правильный ответ</summary>

Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.
```javascript
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```
Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:
```javascript
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);
```
Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.

Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое хуки в React?

<details> 
  <summary>Правильный ответ</summary>

Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов. Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.  

Хук состояния - useState
```javascript
  import React, { useState } from 'react';

  function Example() {
    // Объявляем новую переменную состояния "count"
    const [count, setCount] = useState(0);

    return (
      <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
          Нажми на меня
        </button>
      </div>
    );
  }
```
Вызов useState возвращает две вещи: текущее значение состояния и функцию для его обновления. Эту функцию можно использовать где угодно, например, в обработчике событий. Она схожа с this.setState в классах, но не сливает новое и старое состояние вместе. Единственный аргумент useState — это начальное состояние. В примере выше — это 0, так как наш счётчик начинается с нуля.  

Хук эффекта - useEffect
```javascript
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // По принципу componentDidMount и componentDidUpdate:
  useEffect(() => {
    // Обновляем заголовок документа, используя API браузера
    document.title = `Вы нажали ${count} раз`;
  });

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
```
Когда вы вызываете useEffect, React получает указание запустить вашу функцию с «эффектом» после того, как он отправил изменения в DOM. Поскольку эффекты объявляются внутри компонента, у них есть доступ к его пропсам и состоянию. По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.


- **React.useState**	- хук управления состоянием в функциональных компонентах
useEffect	выполнения побочных эффектов в функциональных компонентах (например, для получения данных или подписки на события).  

- **useContext**	- хук доступа к значению контекста React в функциональном компоненте.  

- **useRef**	- хук создания изменяемых ссылок на элементы или значения, которые сохраняются во время рендеринга.  

- **useCallback**	- хук мемоизации функций для предотвращения ненужных повторных рендеров.  

- **useMemo**	- хук запоминания значений с целью повышения производительности за счет кэширования ресурсоемких вычислений.  

- **useReducer**	- хук управления состоянием с помощью функции reducer, аналогично тому, как это делается в Redux.  

- **useLayoutEffect**	- хук выполнения побочных эффектов подобно useEffect, с той разницей, что эффект запускается синхронно после всех мутаций DOM.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое порталы в React?

<details> 
  <summary>Правильный ответ</summary>

Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.
```javascript
ReactDOM.createPortal(child, container)
```
Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.  

Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
</details>

[Вернуться в меню React Core](#react-core)

## Что такое React Reconciliation (Cверка) и как он работает?

<details> 
  <summary>Правильный ответ</summary>

Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.

При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.

Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.

По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.

</details>

[Вернуться в меню React Core](#react-core)

## Как выполнить рендеринг элементов массива?

<details> 
  <summary>Правильный ответ</summary>

Для рендеринга статического списка можно использовать метод map(), который перебирает элементы и возвращает новый массив элементов React:
```javascript
const languages = [
  "JavaScript",
  "TypeScript",
  "Python",
];

function App() {
  return (
    <div>
      <ul>{languages.map((language) => <li>{language}</li>)}</ul>
    </div>
  );
}
```
Для рендеринга элементов динамического списка используют ключи. Они необходимы для оптимизации процесса рендеринга, позволяя React быстро определить, какие элементы были изменены, удалены или добавлены:
```javascript
import React, { useState } from 'react';

function App() {
 const [clothingItems, setClothingItems] = useState([
   { id: 1, name: "Футболка", size: "M" },
   { id: 2, name: "Шорты", size: "L" },
   { id: 3, name: "Брюки", size: "XL" },
   { id: 4, name: "Платье", size: "XS" },
   { id: 5, name: "Свитер", size: "L" },
 ]);


 return (
   <div className="App">
     <h1>Новые товары</h1>
     <ul>
       {clothingItems.map((item) => (
         <li key={item.id}>
           <h2>{item.name}</h2>
           <p>Размер: {item.size}</p>
         </li>
       ))}
     </ul>
   </div>
 );
}

export default App;
```

</details>

[Вернуться в меню React Core](#react-core)

## Чем управляемые компоненты отличаются от неуправляемых?

<details> 
  <summary>Правильный ответ</summary>

Разница между управляемыми и неуправляемыми компонентами заключается в том, как они управляют своим состоянием и обновляют его.

**Управляемые компоненты** – это компоненты, состояние которых контролируется React. Компонент получает свое текущее значение и обновляет его через реквизиты (пропсы). При изменении значения он также запускает функцию обратного вызова. Это означает, что компонент не хранит собственное внутреннее состояние – вместо этого родительский компонент управляет им и передает значение управляемому компоненту.

```javascript
import { useState } from 'react'; 

function App() { 
  const [value, setValue] = useState(''); 

  return ( 
    <div> 
      <h3>Controlled Component</h3> 
      <input name="name" value={name} onChange={(e) => setValue(e.target.value)} />
      <button onClick={() => console.log(value)}>Get Value</button> 
    </div> 
  ); 
}
```

**Неуправляемые компоненты** - напротив, управляют своим состоянием самостоятельно с помощью ссылок или других методов. Они хранят и обновляют свое состояние самостоятельно, не полагаясь на реквизиты или обратные вызовы. Родительский компонент имеет меньший контроль над состоянием неуправляемых компонентов.
```javascript
import { useRef } from 'react'; 

function App() { 
  const inputRef = useRef(null); 

  return ( 
    <div className="App"> 
      <h3>Uncontrolled Component</h3> 
      <input type="text" name="name" ref={inputRef} /> 
      <button onClick={() => console.log(inputRef.current.value)}>Get Value</button> 
    </div> 
  ); 
} 
```

</details>

[Вернуться в меню React Core](#react-core)

## В чем разница между классовыми и функциональными компонентами?

<details> 
  <summary>Правильный ответ</summary>

Основное различие между классовыми и функциональными компонентами заключается в способе их определения и используемом синтаксисе.  

**Классовые компоненты** определяются как классы **ES6** и расширяют класс `React.Component`. Они используют метод **render** для возврата JSX (JavaScript XML), определяющего вывод компонента. Классовые компоненты имеют доступ к методам жизненного цикла компонента и управлению состоянием через `this.state` и `this.setState()`.
```javascript
class App extends React.Component {
  state = {
    value: 0,
  };

  handleAgeChange = () => {
    this.setState({
      value: this.state.value + 1 
    });
  };

  render() {
    return (
      <>
        <p>Value is {this.state.value}</p>
        <button onClick={this.handleAgeChange}>
        Increment value
        </button>
      </>
    );
  }
} 
```

**Функциональные компоненты** определяются как простые функции JavaScript. Они принимают в качестве аргументов реквизиты и возвращают непосредственно JSX. Функциональные компоненты не имеют доступа к методам жизненного цикла или состоянию. Однако с появлением хуков в React 16.8 функциональные компоненты получили возможность управлять состоянием, использовать контекст и побочные эффекты.
```javascript
import { useState } from 'react';

const App = () => {
  const [value, setValue] = useState(0);

  const handleAgeChange = () => {
    setValue(value + 1);
  };

  return (
      <>
        <p>Value is {value}</p>
        <button onClick={handleAgeChange}>
        Increment value
        </button>
      </>
  );
} 
```
В целом функциональные компоненты считаются более простыми, их легче читать и тестировать. Рекомендуется использовать функциональные компоненты везде, где это возможно, если нет особой необходимости в использовании компонентов на основе классов.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое методы жизненного цикла компонента?

<details> 
  <summary>Правильный ответ</summary>

Методы жизненного цикла – это способ подключения к различным этапам жизненного цикла компонента, позволяющий выполнять определенный код в определенное время. Вот список основных методов:

- **constructor** – первый метод, вызываемый при создании компонента. Он используется для инициализации состояния и привязки обработчиков событий. В функциональных компонентах для аналогичных целей используется хук useState.
- **render** – отвечает за рендеринг JSX-разметки и возвращает содержимое, которое будет выведено на экран.
- **componentDidMount** – вызывается сразу после рендеринга компонента в DOM. Обычно используется для задач инициализации, таких как вызов API или настройка слушателей событий.
- **componentDidUpdate** – вызывается при изменении реквизитов или состояния компонента. Позволяет выполнять побочные эффекты, обновлять компонент на основе изменений или запускать дополнительные вызовы API.
- **componentWillUnmount** – вызывается непосредственно перед удалением компонента из DOM. Используется для очистки ресурсов, которые были установлены в componentDidMount, например, для удаления слушателей событий или отмены таймеров.  

Некоторые методы жизненного цикла (componentWillMount, componentWillReceiveProps и componentWillUpdate) уже устарели, вместо них следует использовать альтернативные методы или хуки.

</details> 

[Вернуться в меню React Core](#react-core)

## В чем заключаются особенности использования useState?

<details> 
  <summary>Правильный ответ</summary>

`useState` возвращает значение состояния и функцию для его обновления.

```javascript
const [value, setValue] = useState('Some state');
```
Во время первого рендеринга возвращаемое состояние соответствует значению, переданному в качестве первого аргумента. Для обновления состояния используется функция setState. Она принимает в качестве параметра новое значение состояния и ставит компонент в очередь на повторный рендеринг. Функция setState может также принимать в качестве параметра функцию обратного вызова, которая принимает в качестве параметра предыдущее значение состояния.

</details>

[Вернуться в меню React Core](#react-core)

## В чем заключаются особенности использования useEffect?

<details> 
  <summary>Правильный ответ</summary>

Хук useEffect позволяет выполнять побочные эффекты в функциональном компоненте. Мутации, подписки, таймеры, логирование и другие побочные эффекты не должны выполняться во время первой фазы рендеринга: это может привести к ошибкам и несоответствиям в пользовательском интерфейсе.

Вместо этого рекомендуется использовать useEffect. Функция, переданная в useEffect, будет выполняться после фазы фиксации, а если в качестве второго параметра передать массив зависимостей, то функция будет вызываться каждый раз, когда одна из зависимостей изменяется.

```javascript
useEffect(() => {
  console.log('Logging something');
}, [])
```

</details>

[Вернуться в меню React Core](#react-core)

## Как отследить размонтирование функционального компонента?

<details> 
  <summary>Правильный ответ</summary>
  
Очень часто useEffect создает ресурсы, которые необходимо очистить или сбросить до того, как компонент покинет экран, например подписку или идентификатор таймера.

Для этого функция, передаваемая в useEffect, может возвращать функцию очистки. Функция очистки запускается перед удалением компонента из пользовательского интерфейса для предотвращения утечек памяти. Кроме того, если компонент отображается несколько раз (как это обычно бывает), то перед выполнением следующего эффекта предыдущий эффект очищается.

```javascript
useEffect(() => {
  function handleChange(value) {
    setValue(value);
  }
  SomeAPI.doFunction(id, handleChange);

  return function cleanup() {
    SomeAPI.undoFunction(id, handleChange);
  };
})
```

</details>

[Вернуться в меню React Core](#react-core)


## Что такое реквизиты(props, пропсы) в React?

<details> 
  <summary>Правильный ответ</summary>

Реквизиты (props, пропсы) – это данные, которые передаются компоненту от родителя. Реквизиты доступны только для чтения и не могут быть изменены.

```javascript
// Родительский компонент
const Parent = () => {
  const data = "Hello, World!";

  return (
    <div>
      <Child data={data} />
    </div>
  );
};

// дочерний компонент
const Child = ({ data }) => {
  return <div>{data}</div>;
};,
```

</details>

[Вернуться в меню React Core](#react-core)

## Что такое менеджер состояний и с какими из них вы работали?

<details> 
  <summary>Правильный ответ</summary>

Менеджер состояний – это инструмент или библиотека, которая помогает управлять состоянием приложения. Менеджер предоставляет централизованное хранилище или контейнер для хранения и управления данными, которые могут быть доступны и обновлены различными компонентами приложения.

Менеджер состояния решает несколько задач. Во-первых, хорошей практикой является отделение данных и связанной с ними логики от компонентов. Во-вторых, при использовании локального состояния и передаче его между компонентами код может стать запутанным из-за возможности глубокой вложенности компонентов. При наличии глобального хранилища мы можем получать доступ к данным и изменять их из любого компонента.

Роль менеджера состояний может исполнять React Context, но лучше использовать библиотеки **Redux** или **MobX**.

</details>

[Вернуться в меню React Core](#react-core)

## В каких случаях можно использовать локальное состояние, а когда следует использовать глобальное состояние?

<details> 
  <summary>Правильный ответ</summary>

Локальное состояние следует применять в тех случаях, когда оно:

- Используется только в рамках одного компонента и не передается другим компонентам.
- Используется в компоненте, который представляет собой отдельный элемент списка.  

Однако если декомпозиция компонента затрагивает вложенные компоненты, передающие данные по иерархии, лучше использовать глобальное состояние.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое пробрасывание пропсов (props drilling)?

<details> 
  <summary>Правильный ответ</summary>

Под пробрасыванием («сверлением») реквизитов понимается процесс передачи реквизитов через несколько уровней вложенных компонентов, даже если некоторые промежуточные компоненты не используют эти пропсы напрямую. Глубокое пробрасывание делает структуру кода сложной и запутанной.

```javascript
// Родительский компонент
const Parent = () => {
  const data = "Hello, World!";

  return (
    <div>
      <ChildA data={data} />
    </div>
  );
};

// Промежуточный дочерний компонент
const ChildA = ({ data }) => {
  return (
    <div>
      <ChildB data={data} />
    </div>
  );
};

// Целевой дочерний компонент
const ChildB = ({ data }) => {
  return <div>{data}</div>;
};
```
В этом примере реквизит data передается от родительского компонента к `ChildA`, а затем от `ChildAк` `ChildB`, хотя `ChildA` напрямую не использует этот реквизит. Этот подход приведет к серьезным проблемам при наличии большого количества уровней вложенности или при необходимости доступа к данным со стороны компонентов, расположенных дальше по дереву: код станет очень сложным для понимания и поддержки.

Устранить проблему пробрасывания можно с помощью контекста или библиотек управления состоянием, таких как Redux или MobX. Эти подходы позволяют получить доступ к данным через компоненты без необходимости передавать реквизиты через каждый промежуточный компонент. Так, например, можно решить проблему с помощью контекста:
```javascript
// Создать контекст 
const DataContext = React.createContext();

// Обернуть родительский компонент контекстом
const Parent = () => {
  const data = "Hello World!";

  return (
    <DataContext.Provider value={data}>
      <ChildA />
    </DataContext.Provider>
  );
};

// Получить данные из контекста в вложенных компонентах
const ChildB = () => {
  const data = React.useContext(DataContext);
  
  return <div>{data}</div>; 
};
```

</details>

[Вернуться в меню React Core](#react-core)

## Как работает условный рендеринг элементов?

<details> 
  <summary>Правильный ответ</summary>

Для условной отрисовки можно использовать любые условные операторы, в том числе и тернарные:
```javascript
return (
  <div>
    {isVisible && <span>I'm visible!</span>}
  </div>
);
```

```javascript
return (
  <div>
    {isOnline ? <span>I'm online!</span> : <span>I'm offline</span>}
  </div>
);
```

```javascript
if (isOnline) {
  element = <span>I'm online!</span>;
} else {
  element = <span>I'm offline</span>;
}

return (
  <div>
    {element}
  </div>
);
```

</details>

[Вернуться в меню React Core](#react-core)

## Для чего и как используется UseMemo?

<details> 
  <summary>Правильный ответ</summary>

Хук useMemo используется для кэширования и запоминания результатов вычислений. В него передается функция, которая производит вычисления, и массив зависимостей. Хук будет пересчитывать значение только тогда, когда изменится одна из зависимостей – эта оптимизация помогает избежать ресурсозатратных вычислений при каждом рендере.

```javascript
const memoValue = useMemo(() => computeFunc(paramA, paramB), [paramA, paramB]);
```

</details>

[Вернуться в меню React Core](#react-core)

## Для чего используется useCallback и как он работает?

<details> 
  <summary>Правильный ответ</summary>

Хук **useCallback** возвращает мемоизированную версию коллбэк-функции. Эта версия будет изменяться только в том случае, если изменятся значения зависимостей в массиве зависимостей, переданном в **useCallback**.

- Хук используют для передачи функций обратного вызова в оптимизированные дочерние компоненты, которые для предотвращения лишних отрисовок полагаются на ссылочное равенство (===).
- Благодаря тому, что **useCallback** возвращает мемоизированную версию, ссылка на коллбэк будет стабильной между рендерами, если зависимости не изменились.  

Таким образом, **useCallback** позволяет оптимизировать производительность за счет избежания лишних отрисовок.
```javascript
const callbackValue = useCallback(() => computeFunc(paramA, paramB), [paramA, paramB]);
```

</details>

[Вернуться в меню React Core](#react-core)

## В чем разница между useMemo и useCallback?

<details> 
  <summary>Правильный ответ</summary>

- **useMemo** используется для запоминания **результата вычислений**, а **useCallback** – для запоминания **самой функции**.
- **useMemo** кэширует вычисленное значение и возвращает его при последующих рендерах, если зависимости не изменились.
- **useCallback** кэширует саму функцию и возвращает тот же экземпляр, если зависимости не изменились.

</details>

[Вернуться в меню React Core](#react-core)

## Как используют React Context?

<details> 
  <summary>Правильный ответ</summary>

**React Context** обеспечивает передачу данных по дереву компонентов без пробрасывания реквизитов через каждый промежуточный уровень (см. ответ на вопрос 21). Context позволяет создать глобальное состояние, доступ к которому может получить любой компонент в дереве, независимо от его положения. Контекст полезен, когда необходимо обмениваться данными между несколькими компонентами, не связанными напрямую.

**React Context API** состоит из трех основных частей:
**createContext** – используется для создания нового объекта контекста.  
**Context.Provider** – используется для предоставления значения контексту. Он оборачивает компоненты, которым необходим доступ к значению.  
**Context.Consumer** или хук **useContext** – этот компонент или хук используется для получения значения из контекста. Он может быть использован в любом компоненте, входящем в состав провайдера контекста.  

Использование React Context позволяет избежать передачи реквизитов через несколько уровней компонентов (**prop drilling**) и легко управлять состоянием на более высоком уровне – это улучшает читаемость кода и производительность приложения.

</details>

[Вернуться в меню React Core](#react-core)

## Для чего используется useContext и как он работает?

<details> 
  <summary>Правильный ответ</summary>

В типичном React-приложении данные передаются сверху вниз (от родительского компонента к дочернему) с помощью реквизитов (пропсов). Однако такой способ может оказаться слишком громоздким для некоторых типов реквизитов, которые нужно передавать многим компонентам – из-за языка или темы пользовательского интерфейса, например. Контекст предоставляет возможность обмена данными между компонентами без необходимости явной передачи реквизита через каждый уровень дерева.

Компонент, вызывающий useContext, всегда будет перерисовываться при изменении значения контекста. Если перерисовка компонента требует больших затрат, можно оптимизировать ее с помощью мемоизации.
```javascript
const App = () => {
  const theme = useContext(ThemeContext);

  return (
    <div style={{ color: theme.palette.primary.main }}>
      Some div
    </div>
  );
}
```

</details>

[Вернуться в меню React Core](#react-core)

## Для чего используется useRef и как он работает?

<details> 
  <summary>Правильный ответ</summary>

Хук useRef возвращает ссылку (ref-объект), которая может быть привязана к текущему значению какого-либо элемента или состояния компонента. При создании этого объекта, начальное значение устанавливается равным переданному аргументу. Такой объект сохраняется между различными рендерами компонента и его значение не меняется: если мы изменим значение переданного аргумента, это не повлияет на ref-объект.

Обычно useRef используется для доступа к дочерним элементам в императивном стиле, то есть явно обращаясь к какому-то элементу DOM. Это позволяет выполнять различные действия над элементом – изменять стили, добавлять события и т.д.
```javascript
const App = () => {
  const inputRef = useRef(null);

  const buttonClick = () => {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={buttonClick}>Focus on input tag</button>
    </>
  )
}
```

</details>

[Вернуться в меню React Core](#react-core)

## Что такое React.memo()?

<details> 
  <summary>Правильный ответ</summary>

React.memo() – это компонент высшего порядка, который используется для оптимизации производительности веб-приложений. Если компонент, который вы хотите оптимизировать, всегда отображает один и тот же результат с неизменными реквизитами (props), вы можете обернуть его вызов в React.memo, чтобы запомнить его результат. Таким образом, React может использовать последний отрендеренный результат этого компонента вместо того, чтобы снова его рендерить, если входные данные не изменились. Это помогает оптимизировать производительность, так как повторный рендеринг может быть затратным по ресурсам. Важно отметить, что React.memo влияет только на изменение входных данных (реквизитов): если функциональный компонент, обернутый в React.memo, использует useState, useReducer или useContext для изменения своего состояния или контекста, он все равно будет перерисован при изменении этих состояний или контекстов.

```javascript
import { memo } from 'react';

const MemoComponent = memo(MemoComponent = (props) => {
  // ...
});
```

</details>

[Вернуться в меню React Core](#react-core)

## Что такое фрагмент React?

<details> 
  <summary>Правильный ответ</summary>

Возврат нескольких элементов из компонента – обычная практика в React. Однако это может привести к созданию большого количества элементов в дереве виртуального DOM, отчего пострадает производительность приложения.

Фрагменты React позволяют группировать несколько элементов внутри функции-компонента, избегая таким образом создания большого количества узлов в виртуальном DOM. Это улучшает производительность приложения и читаемость кода.

```javascript
<>
  <OneChild />
  <AnotherChild />
</>
// or
<React.Fragment>
  <OneChild />
  <AnotherChild />
</React.Fragment>
```

</details>

[Вернуться в меню React Core](#react-core)

## Что такое React Reconciliation?

<details> 
  <summary>Правильный ответ</summary>

React использует алгоритм согласования (reconciliation) для определения изменений между старым и новым деревом виртуального DOM. Этот алгоритм сравнивает каждый элемент старого дерева с соответствующим элементом нового дерева и определяет, какие элементы были добавлены, удалены или обновлены. Затем React применяет эти изменения к реальному DOM-дереву, обновляя только те элементы, которые действительно изменились.

Этот алгоритм позволяет значительно повысить производительность React-приложений, так как он не обновляет все элементы дерева при каждом изменении, а только те, которые действительно нуждаются в обновлении.

</details>

[Вернуться в меню React Core](#react-core)

## Зачем нужны ключи в списках при использовании map()?

<details> 
  <summary>Правильный ответ</summary>

Ключи в списках помогают React отслеживать изменения в списке. Когда элементы в списке обновляются, удаляются или добавляются, React использует ключи для определения того, какие изменения произошли и как обновить DOM. Без ключей React не сможет эффективно обновлять список, что может привести к снижению производительности. При использовании map() необходимо указывать ключи, чтобы React мог связать каждый элемент списка с соответствующей записью в массиве. При выборе ключа лучше использовать уникальные идентификаторы элементов, чтобы React мог легко определить, какой элемент был изменен.

```javascript
const languages = [
  {
    id: 1,
    lang: "JavaScript",
  },
  {
    id: 2,
    lang: "TypeScript",
  },
  {
    id: 3,
    lang: "Python",
  },
];

const App = () => {
  return (
    <div>
      <ul>{languages.map((language) => (
        <li key={`${language.id}_${language.lang}`}>{language.lang}</li>
      ))}
      </ul>
    </div>
  );
}
```

</details>

[Вернуться в меню React Core](#react-core)

## Как отследить изменения поля объекта в функциональном компоненте?

<details> 
  <summary>Правильный ответ</summary>

Для этого необходимо использовать хук useEffect и передать поле объекта в виде массива зависимостей:
```javascript
useEffect(() => {
  console.log('Changed!')
}, [obj.someField])
```

</details>

[Вернуться в меню React Core](#react-core)

## Как получить доступ к элементу DOM?

<details> 
  <summary>Правильный ответ</summary>

Чтобы получить доступ к DOM-элементу в React, нужно создать ссылку на этот элемент. Это можно сделать с помощью функции React.createRef() или хука useRef(). После создания ссылки ее нужно присоединить к компоненту React, для которого нужно получить доступ к DOM, с помощью атрибута ref. Затем, чтобы получить доступ к самому элементу DOM, можно обратиться к созданной ссылке через ref.current:
```javascript
const App = () => {
  const myRef = useRef(null);

  const handleClick = () => {
    console.log(myRef.current); // Accessing the DOM element
  };

  return (
    <div>
      <input type="text" ref={myRef} />
      <button onClick={handleClick}>Click Me</button>
    </div>
  );
}
```

</details>

[Вернуться в меню React Core](#react-core)

## Что такое пользовательский хук?

<details> 
  <summary>Правильный ответ</summary>

Пользовательский хук в React – это функция, которая позволяет повторно использовать логику внутри компонентов. Хуки позволяют инкапсулировать определенную логику и использовать ее в разных компонентах. Названия пользовательских хуков обычно начинаются с use, и они могут вызывать другие хуки при необходимости.

</details>

[Вернуться в меню React Core](#react-core)

## Что такое публичный API?

<details> 
  <summary>Правильный ответ</summary>

В контексте индексных файлов под Public API обычно понимается интерфейс или функции, которые открыты и доступны для внешних модулей или компонентов. Вот пример кода индексного файла, представляющего Public API:

```javascript
// index.js

export function greet(name) {
  return `Hello, ${name}!`;
}

export function calculateSum(a, b) {
  return a + b;
}
```
В данном примере файл index.js выступает в роли публичного API, в котором экспортируются функции greet() и calculateSum(). Доступ к этим функциям может быть получен из других модулей путем их импорта. Другие модули могут импортировать и использовать эти функции как часть своей реализации:
```javascript
// main.js

import { greet, calculateSum } from './index.js';

console.log(greet('John')); // Hello, John!
console.log(calculateSum(5, 3)); // 8
```
Экспортируя определенные функции из индексного файла, мы определяем публичный API модуля, позволяя другим модулям использовать эти функции.

</details> 

[Вернуться в меню React Core](#react-core)

## Перечислите правила создания пользовательского хука.

<details> 
  <summary>Правильный ответ</summary>

При написании такого хука нужно соблюдать несколько правил:

- Название хука должно начинаться с `use`.
- Следует использовать сначала встроенные хуки, если они решают нужную задачу, прежде чем создавать свои.
- Нельзя вызывать хук условно. Хук надо вызывать тогда, когда это необходимо.
- В хуке должна быть только логика, которую можно использовать повторно. Не стоит добавлять в него код, который нужен только в одном месте.
- Хук должен быть чистой функцией.
- Хук может возвращать значение или вызывать другие хуки. Это позволяет создавать цепочки обработки данных.
- Название хука должно быть понятным и отражать его назначение. Это поможет другим разработчикам понять, что делает этот хук и как его можно использовать.

</details> 

[Вернуться в меню React Core](#react-core)

## Что такое серверный рендеринг (Server-Side Rendering)?

<details> 
  <summary>Правильный ответ</summary>

**Серверный рендеринг** (SSR) – это техника, при которой сервер создает готовую к отображению веб-страницу и отправляет ее пользователю. Этот подход отличается от традиционного, при котором сервер отправляет только исходный код HTML, а готовый вид страница приобретает после обработки клиентским браузером.

Основная цель серверного рендеринга – улучшение скорости загрузки страниц и повышение позиций в поисковом ранжировании. Используя SSR, сервер подготавливает страницу полностью, включая динамическое содержимое. В результате пользователь получает готовую к просмотру страницу, без необходимости выполнения дополнительных запросов к серверу.

Применение SSR особенно полезно для приложений, где много контента генерируется с помощью JavaScript, так как поисковые системы не могут индексировать такой контент. Используя серверный рендеринг, поисковики могут легко увидеть и проиндексировать все содержимое страницы.

Помимо React, SSR поддерживается многими современными фреймворками, например Next.js, Nuxt.js и Meteor.js.

</details> 

[Вернуться в меню React Core](#react-core)

## Перечислите преимущества серверного рендеринга.

<details> 
  <summary>Правильный ответ</summary>

Серверный рендеринг имеет несколько весомых преимуществ:

- **Улучшение времени загрузки** – серверный‌ рендеринг позволяет серверу отправить пользователю полностью готовую к отображению HTML-страничку, уменьшая тем самым объем обработки на стороне клиента и ускоряя загрузку страницы.
- **Улучшение видимости в поисковых системах** – поисковые роботы могут легко просматривать и индексировать содержание страниц, обработанных на стороне сервера, что приводит к улучшению видимости в результатах поиска.
- **Обеспечение доступности** – серверный рендеринг обеспечивает доступность контента для пользователей с отключенным JavaScript, гарантируя надежное и полное отображение всех страниц приложения.
- **Повышение производительности в условиях низкой‌ скорости интернета** – серверный рендеринг уменьшает объем данных, получаемых пользователем.  

Несмотря на все преимущества SSR, важно отметить, что по сравнению с методами рендеринга на стороне клиента он может создавать большую нагрузку на сервер и усложнять обслуживание. Необходимо тщательно учитывать такие факторы, как кэширование, масштабируемость и оптимизация производительности рендеринга на стороне сервера.

</details>