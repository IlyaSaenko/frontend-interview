[Вопросы для собеседования](README.md)

# JS Core

+ [Какие типы данных существуют в JavaScript?](#Какие-типы-данных-существуют-в-JavaScript)
+ [Что такое цикл событий (event loop) и как он работает?](#Что-такое-цикл-событий-event-loop-и-как-он-работает)
+ [Как работает ключевое слово this?](#Как-работает-ключевое-слово-this)
+ [Что такое Promise (Промис)?](#Что-такое-Promise-Промис)
+ [Что такое статический метод класса (static)?](#Что-такое-статический-метод-класса-static)
+ [Что такое Set, Map, WeakSet и WeakMap?](#Что-такое-Set-Map-WeakSet-и-WeakMap)
+ [Что такое переменные и функции?](#Что-такое-переменные-и-функции)
+ [Что такое Делегирование событий?](#Что-такое-Делегирование-событий)
+ [Как работает прототипное наследование?](#Как-работает-прототипное-наследование)
+ [В чём различие между переменными, значение которых: null, undefined и не объявлено?](#В-чём-различие-между-переменными-значение-которых-null-undefined-и-не-объявлено)
+ [Что такое замыкание и как/для чего его используют?](#Что-такое-замыкание-и-какдля-чего-его-используют)
+ [Какое основное различие между циклом forEach и циклом .map()?](#Какое-основное-различие-между-циклом-forEach-и-циклом-map)
+ [В каких случаях обычно используются анонимные функции?](#В-каких-случаях-обычно-используются-анонимные-функции)
+ [В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?](#В-чем-разница-между:-function-Person(){},-var-person-=-Person(),-и-var-person-=-new-Person())
+ [В чем разница между .call и .apply?](#В-чем-разница-между-.call-и-.apply)
+ [Что делает и для чего нужна функция Function.prototype.bind?](#Что-делает-и-для-чего-нужна-функция-Function.prototype.bind)
+ [Расскажите об Ajax более подробно.](#Расскажите-об-Ajax-более-подробно.)
+ [Какие преимущества и недостатки в использовании Ajax?](#Какие-преимущества-и-недостатки-в-использовании-Ajax)
+ [Расскажите, что такое поднятие (hoisting) переменных.](#Расскажите-что-такое-поднятие-hoisting-переменных)
+ [В чём разница между «атрибутом» (attribute) и «свойством» (property)?](#В-чём-разница-между-«атрибутом»-(attribute)-и-«свойством»-(property))
+ [В чём разница между == и ===?](#В-чём-разница-между-==-и-===)
+ [Почему тернарный оператор так называется?](#Почему-тернарный-оператор-так-называется)
+ [Что делает строчка "use strict";? Какие достоинства и недостатки от её использования?](#Что-делает-строчка-"use-strict";?-Какие-достоинства-и-недостатки-от-её-использования)
+ [Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?](#Почему-считается-хорошим-тоном-оставить-глобальную-область-видимости-(global-scope)-в-нетронутом-состоянии)
+ [Промис](#Промис)
+ [Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?](#Какие-преимущества-и-недостатки-при-использовании-промисов-вместо-колбэков-(callbacks))
+ [Какие инструменты и методы вы используете при отладке кода?](#Какие-инструменты-и-методы-вы-используете-при-отладке-кода)
+ [Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?](#Какие-языковые-конструкции-вы-используете-для-итерации-по-свойствам-объекта-и-элементам-массива)
+ [Объясните разницу между синхронными и асинхронными функциями.](#Объясните-разницу-между-синхронными-и-асинхронными-функциями)
+ [Что такое цикл событий (event loop)? В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?](#Что-такое-цикл-событий-(event-loop)?-В-чём-разница-между-стеком-вызовов-(call-stack)-и-очередью-событий-(task-queue))
+ [Объясните разницу при использовании foo в function foo() {} и var foo = function() {}.](#Объясните-разницу-при-использовании-foo-в-function-foo()-{}-и-var-foo-=-function()-{})
+ [В чём различие между переменными, созданными при помощи let, var и const?](#В-чём-различие-между-переменными,-созданными-при-помощи-let,-var-и-const)
+ [В чём разница между классом в ES6 и функцией-конструктором в ES5?](#В-чём-разница-между-классом-в-ES6-и-функцией-конструктором-в-ES5)
+ [Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?](#Можете-ли-вы-привести-пример-использования-стрелочных-функции-=>?-Чем-они-отличаются-от-других-функций)
+ [Дайте определение функции высшего порядка.](#Дайте-определение-функции-высшего-порядка)
+ [Можете ли вы привести пример деструктуризации объекта или массива?](#Можете-ли-вы-привести-пример-деструктуризации-объекта-или-массива)
+ [Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?](#Шаблонные-строки-в-ES6-намного-упрощают-создание-строк,-можете-ли-вы-привести-пример-их-использования)
+ [В чём преимущества использования spread оператора, чем он отличается от rest оператора?](#В-чём-преимущества-использования-spread-оператора,-чем-он-отличается-от-rest-оператора)
+ [Каким образом можно обмениваться кодом между файлами?](#Каким-образом-можно-обмениваться-кодом-между-файлами)
+ [В чем разница между async и defer?](#В-чем-разница-между-async-и-defer)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)
+ [Какими способами можно визуально скрыть элемент?](#Какими-способами-можно-визуально-скрыть-элемент)
+ [Плавающие элементы (floats), как работают?](#Плавающие-элементы-floats-как-работают)


## Какие типы данных существуют в JavaScript?

<details> 
  <summary>Правильный ответ</summary>

- Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.  
- Строка «string».  
- Булевый (логический) тип «boolean».  
- Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».  
- Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.  
- Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.  
- Тип «number» не может содержать числа больше, чем (253-1), или меньше, чем -(253-1). Тип «bigint» даёт возможность работать с целыми числами произвольной длины.  
- Объекты «object» - Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
</details>

[Вернуться в меню JS Core](#js-core)

## Что такое цикл событий (event loop) и как он работает?

<details> 
  <summary>Правильный ответ</summary>
Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.  
Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.  
Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.

![Пример](https://camo.githubusercontent.com/9b6e889510f17485e281c3cd6281f1c1b6389ec0b0a5f3d49b30fdf866a69905/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a71757954494f733268696f4378316a5251372d6f6a772e706e67)

</details>

[Вернуться в меню JS Core](#js-core)

## Как работает ключевое слово this?

<details> 
  <summary>Правильный ответ</summary>
	
Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.

Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.  

В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.

В пределах функции значение this зависит от того, каким образом вызвана функция:

Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.
</details>

[Вернуться в меню JS Core](#js-core)

## Что такое Promise (Промис)?

<details> 
  <summary>Правильный ответ</summary>

Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).  
Синтаксис создания Promise:
```javascript
let promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
});
```
Универсальный метод для навешивания обработчиков:
```javascript
promise.then(onFulfilled, onRejected);
```
- `onFulfilled` – функция, которая будет вызвана с результатом при resolve.  
- `onRejected` – функция, которая будет вызвана с ошибкой при reject.  

Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:
```javascript
// Создаётся объект promise
let promise = new Promise((resolve, reject) => {

  setTimeout(() => {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);

});

// promise.then навешивает обработчики на успешный результат или ошибку
promise
  .then(
    result => {
      // первая функция-обработчик - запустится при вызове resolve
      alert("Fulfilled: " + result); // result - аргумент resolve
    },
    error => {
      // вторая функция - запустится при вызове reject
      alert("Rejected: " + error); // error - аргумент reject
    }
  );
```
В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».
</details>

[Вернуться в меню JS Core](#js-core)

##  Что такое статический метод класса (static)?

<details> 
  <summary>Правильный ответ</summary>
  
Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.
```javascript
  class Repo {
    static getName() {
      return "Repo name is modern-js-cheatsheet"
    }
  }

  // нам не нужно создавать объект класса Repo
  console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

  let r = new Repo();
  console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией
```
Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
</details>

[Вернуться в меню JS Core](#js-core)

## Что такое Set, Map, WeakSet и WeakMap?

<details> 
  <summary>Правильный ответ</summary>
В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.  

Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
```javascript
'use strict';

let map = new Map();

map.set('1', 'str1');   // ключ-строка
map.set(1, 'num1');     // число
map.set(true, 'bool1'); // булевое значение

// в обычном объекте это было бы одно и то же,
// map сохраняет тип ключа
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```
Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
```javascript
'use strict';

let set = new Set();

let vasya = {name: "Вася"};
let petya = {name: "Петя"};
let dasha = {name: "Даша"};

// посещения, некоторые пользователи заходят много раз
set.add(vasya);
set.add(petya);
set.add(dasha);
set.add(vasya);
set.add(petya);

// set сохраняет только уникальные значения
alert( set.size ); // 3

set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
```
WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
```javascript
// текущие активные пользователи
let activeUsers = [
  {name: "Вася"},
  {name: "Петя"},
  {name: "Маша"}
];

// вспомогательная информация о них,
// которая напрямую не входит в объект юзера,
// и потому хранится отдельно
let weakMap = new WeakMap();

weakMap.set(activeUsers[0], 1);
weakMap.set(activeUsers[1], 2);
weakMap.set(activeUsers[2], 3);
weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

alert( weakMap.get(activeUsers[0]) ); // 1

activeUsers.splice(0, 1); // Вася более не активный пользователь

// weakMap теперь содержит только 2 элемента

activeUsers.splice(0, 1); // Петя более не активный пользователь

// weakMap теперь содержит только 1 элемент
```
</details>

[Вернуться в меню JS Core](#js-core)

## Что такое переменные и функции?

<details> 
  <summary>Правильный ответ</summary>

Переменная — универсальное «хранилище» для любых данных с определенным именем. 

Функция — это набор инструкций, который может быть выполнен по запросу внешнего кода. 

Функция в JavaScript — это объект. Он может быть передан как значение.
</details>

[Вернуться в меню JS Core](#js-core)

## Что такое Делегирование событий?

<details> 
  <summary>Правильный ответ</summary>

Делегирование событий — паттерн для обработки событий в браузере. Его удобно использовать, когда нужно схожим образом обрабатывать события на нескольких похожих элементах. Например, элементах списка, ячейках таблицы, элементах формы. 

Он основывается на использовании погружения и всплытия событий в JavaScript. С помощью этого паттерна можно не назначать обработчик на каждый элемент, а назначить обработчик на их общего родителя. Дальше нужно обработать событие, когда оно «всплывет», и получить информацию о том, с каким именно элементом произошло событие из свойств объекта события.

![Пример](https://sky.pro/media/wp-content/webp-express/webp-images/uploads/2022/10/image3.png.webp)

Всплытие событий позволяет реализовать один из самых важных приёмов разработки - **делегирование**.

Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент `event.target`, понять на каком потомке произошло событие и обработать его.

**Алгоритм:**

1. Вешаем обработчик на контейнер.
2. В обработчике: получаем event.target.
3. В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.

**Зачем использовать:**

- Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.
- Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
- Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.
</details>

[Вернуться в меню JS Core](#js-core)

## Как работает прототипное наследование?

<details> 
  <summary>Правильный ответ</summary>
Прототипом объекта А называется объект B, свойства и методы которого доступны для объекта A как собственные.


* У любого объекта есть прототип, на который указывает его свойство `__proto__` и который также является объектом.
* У любой функции есть ассоциированный с ней объект, на который в контексте функции указывает свойство prototype. В него как в контейнер обычно складывают свойства и методы для работы с определенным классом объектов.
* Такой контейнер автоматически становится прототипом объектов, создаваемых функциями-конструкторами
* Для редактирования прототипной ссылки объекта используют метод Object.create() - он перезаписывает объект заново и выставляет в нем ссылку на нужный прототип.
* Ссылки связанных друг с другом объектов образуют прототипную цепочку, которая лежит в основе прототипного наследования. Ярким примером такого наследования является цепочка узлов DOM модели.

Пример
```javascript

let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true

```

</details>

[Вернуться в меню JS Core](#js-core)

## В чём различие между переменными, значение которых: null, undefined и не объявлено?

<details> 
  <summary>Правильный ответ</summary>

**undefined** - это переменная, которая была объявлена, но у нее нет значения.

**null** - значение переменной.

**undeclared** - переменная, объявленная без ключевого слова 'var'.

Для проверки можно использовать console.log() и typeof.

</details>

[Вернуться в меню JS Core](#js-core)

## Что такое замыкание и как/для чего его используют?

<details> 
  <summary>Правильный ответ</summary>

Если одна функция определена внутри другой, то внутренняя имеет доступ к ОВ внешней. Это называется замыканием (а также "лексической ОВ" или "статическая").  
При выполнении функции используется та область видимости переменных, которая существовала на момент объявления этой функции. Это лексическая область видимости.

</details>

[Вернуться в меню JS Core](#js-core)

## Какое основное различие между циклом forEach и циклом .map()?

<details> 
  <summary>Правильный ответ</summary>

forEach перебирает массив и не изменяет его.  
.map() создает копию массива и изменяет копию.

</details>

[Вернуться в меню JS Core](#js-core)

## В каких случаях обычно используются анонимные функции?

<details> 
  <summary>Правильный ответ</summary>

Анонимные функции часто используются для выполнения какого-то кода в коллбэках, где не нужно создавать отдельную именную функцию под это действие.

</details>

[Вернуться в меню JS Core](#js-core)

## В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?

<details> 
  <summary>Правильный ответ</summary>

`function Person(){}` - Мы создаем функцию с именем Person.   
`var person = Person()` - Мы вызываем функцию Person и результат сохраняем в переменную person.   
`var person = new Person()` - Мы создаем новый объект, используя функцию-конструктор Person.

</details>

[Вернуться в меню JS Core](#js-core)

## В чем разница между .call и .apply?

<details> 
  <summary>Правильный ответ</summary>

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

```javascript
function add(a, b) {
  return a + b;
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

</details> 

[Вернуться в меню JS Core](#js-core)

## Что делает и для чего нужна функция Function.prototype.bind?

<details> 
  <summary>Правильный ответ</summary>

Метод `bind()` создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передается набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при ее вызове.

</details>

[Вернуться в меню JS Core](#js-core)

## Расскажите об Ajax более подробно.

<details> 
  <summary>Правильный ответ</summary>

Ajax (аббревиатура от "Asynchronous Javascript And Xml) - технология обращения к серверу без перезагрузки страницы.   
За счёт этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп.   
Использовать XML не обязательно, под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.

**Элементы интерфейса**   
AJAX полезен для форм и кнопок, связанных с элементарными действиями: добавить в корзину, подписаться, и т.п.

**Динамическая подгрузка данных**   
Например, дерево, которое при раскрытии узла запрашивает данные у сервера. 

**Живой поиск**   
Классический пример использования AJAX, взятый на вооружение современными поисковыми системами.

Обычно для обмена данными используются форматы:

- JSON - для отправки и получения структурированных данных, объектов.

- XML - если сервер почему-то работает в формате XML, то можно использовать и его.

- HTML/текст - можно и просто загрузить с сервера код HTML или текст для показа на странице.

- Бинарные данные, файлы - гораздо реже, в современных браузерах есть удобные средства для них.

</details>

[Вернуться в меню JS Core](#js-core)

## Какие преимущества и недостатки в использовании Ajax?

<details> 
  <summary>Правильный ответ</summary>
  
**Преимущества**   
- Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.   
 - Сокращение количества подключений к серверу, поскольку сткипты и таблицы стилей нужно запрашивать только один раз.   
 - Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.

 **Недостатки**   
 - Сложнее реализовать добавление динамической веб-страницы в закладки.   
 - Не работает, если в браузере отключен JavaScript.
 - Некоторые поисковые роботы не выполянют JS и не видят данные, загружаемые при помощи JS. 

</details>

[Вернуться в меню JS Core](#js-core)


## Расскажите, что такое поднятие (hoisting) переменных.

<details> 
  <summary>Правильный ответ</summary>

Поднятие (hoisting) — это термин, используемый для объяснения поведения объявлений переменных в коде. Переменные, объявленные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Поднимается только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

```javascript
// объявления переменных через var поднимаются.

console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1   

// объявления переменных через let/const НЕ поднимаются.   

console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

При объявлении функции её тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.

</details>

[Вернуться в меню JS Core](#js-core)

## В чём разница между «атрибутом» (attribute) и «свойством» (property)?

<details> 
  <summary>Правильный ответ</summary>

Атрибуты определены в разметке HTML, а свойства определены в DOM. Большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов. Но они не идентичны.  

**Атрибуты**   
- Всегда являются строками.
- Их имя нечувствительно к регистру.
- Видны в innerHTML.

**Свойства**   
- Могут иметь любое значение.
- Названия свойств чувствительны к регистру.
- Работают за счёт того, что DOM-узлы являются объектами JS.

</details>

[Вернуться в меню JS Core](#js-core)

## В чём разница между == и ===?

<details> 
  <summary>Правильный ответ</summary>
`==` - это оператор абстрактного сравнения, а `===` - оператор строгого сравнения. Оператор `==` будет сравнивать на равенство после выполнения любых необходимых преобразований типов. Оператор `===` не будет выполнять преобразование типов, поэтому, если два занчения не одного типа, `===` просто вернет `false`.
</details>

[Вернуться в меню JS Core](#js-core)

## Почему тернарный оператор так называется?

<details> 
  <summary>Правильный ответ</summary>
"Тернарный" означает три. Троичное выражение принимает три операнда: условие, выражение "then" и выражение "else".

</details>

[Вернуться в меню JS Core](#js-core)

## Что делает строчка "use strict";? Какие достоинства и недостатки от её использования?

<details> 
  <summary>Правильный ответ</summary>

`'use strict'` это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

**Преимущества**

- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).
- Требует, чтобы имена параметров функции были уникальными.
- this в глобальной области видимости равно undefined.
- Перехватывает распространённые ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

**Недостатки**

- Нельзя использовать некоторые особенности языка, к котороым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме, может вызвать проблемы.

</details>

[Вернуться в меню JS Core](#js-core)

## Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?

<details> 
  <summary>Правильный ответ</summary>

Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имён для определения своих переменных, то могут возникнуть конфликты.

</details>

[Вернуться в меню JS Core](#js-core)

##  Промис 

<details> 
  <summary>Правильный ответ</summary>
  
Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причину, по которой оно не было выполнено (например, произошла ошибка сети). Промис может находиться в одном из 3 возможных состояний: выполнено, отклонено или ожидает выполнения. При использовании промисов можно добавлять callback-функции для обработки выполненного значения или причины отказа.

</details>

[Вернуться в меню JS Core](#js-core)

## Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?

<details> 
  <summary>Правильный ответ</summary>
**Преимущества**

* Помогает избежать "callback hell", который может быть нечитаемым.
* Упрощает написание последовательного удобочитаемого асинхронного кода с помощью then().
* Упрощает написание параллельного асинхронного кода с помощью Promise.all().
* С использованием промисов можно избежать следующих проблем: колбэк-функция была вызвана слишком рано, поздно или вовсе не была вызвана; функция была вызвана слишком мало или слишком много раз; не удалось передать необходимую среду/параметры; были пропущены ошибки/исключения.

**Недостатки**

* Чуть более сложный код.
* В старых браузерах, где не поддерживается ES2015, нужно загрузить полифил, чтобы их использовать.
</details>

[Вернуться в меню JS Core](#js-core)

## Какие инструменты и методы вы используете при отладке кода?

<details> 
  <summary>Правильный ответ</summary>

* Chrome Devtools
* Отладка при помощи старого доброго console.log

</details>

[Вернуться в меню JS Core](#js-core)

## Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?

<details> 
  <summary>Правильный ответ</summary>

**Для объектов**

* `for-in` циклы — `for (var property in obj)`.
* `Object.keys()` — `Object.keys(obj).forEach(function(property) {…})`.   
`Object.keys()` — это статический метод, который возвращает все перечисляемые свойства объекта.
* `Object.getOwnPropertyNames()` — `Object.getOwnPropertyNames(obj).forEach(function(property) {…})`. `Object.getOwnPropertyNames()` — это статический метод, который возвращает все перечисляемые и неперечисляемые свойства объекта.

**Для массивов**

* Циклы `for` — `for(var i = 0; i < arr.length; i++)`;
* `forEach` — `arr.forEach(function(el, index) {…})`.

</details>

[Вернуться в меню JS Core](#js-core)

## Объясните разницу между синхронными и асинхронными функциями.

<details> 
  <summary>Правильный ответ</summary>

Синхронные функции являются блокирующими, а асинхронные - нет. В синхронных функциях одна операция должна завершиться, прежде чем будет запущена следующая операция. В этом случае скрипт выполняется строго по порядку операций, и выполнение скрипта приостанавливается, если одна из операций занимает очень много времени.  

Асинхронные функции обычно принимают callback-функцию в качестве параметра, и выполнение продолжается на следующей строке сразу после вызова асинхронной функции. Callback-функция вызывается только тогда, когда асинхронная операция завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка данных с веб сервера или запросы к базе данных, должны выполняться асинхронно, чтобы основной поток мог продолжать выполнять другие операции вместо блокировки до завершения этой долгой операции (в случае браузеров пользовательский интерфейс будет зависать).

</details>

[Вернуться в меню JS Core](#js-core)

## Что такое цикл событий (event loop)? В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?

<details> 
  <summary>Правильный ответ</summary>

Цикл событий - это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается с стек вызовов для выполнения.  

`Stack` - "первым пришел, последним вышел" или "последним пришел, первым вышел", что то же самое.
`Queue` - "первым пришел, первым ушел".

</details>

[Вернуться в меню JS Core](#js-core)

## Объясните разницу при использовании foo в function foo() {} и var foo = function() {}.

<details> 
  <summary>Правильный ответ</summary>

Первое - объявление функции, а второе - функциональное выражение. Ключевое отличие состоит в том, что тело функции при объявлении поднимается наверх, а тело функциональных выражения - нет (они имеют такое же поведение поднятия, что и переменные).

</details>

[Вернуться в меню JS Core](#js-core)

## В чём различие между переменными, созданными при помощи let, var и const?

<details> 
  <summary>Правильный ответ</summary>

Переменные, объявленные при помощи ключевого слова `var`, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции, — к глобальному объекту. `let` и `const` относятся к блочной области видимости — это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок if-else или цикл for).

```javascript
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

console.log(var); // bar
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

`var` позволяет поднимать переменные и на них можно ссылаться в коде до их объявления. `let` `const` не позволяют этого и выдают ошибку.

Переопределение переменной с помощью `var` не вызовет ошибку, в отличие от `let` и `const`.

`let` отличается от `const` тем, что изменять значение `const` нельзя.

</details>

[Вернуться в меню JS Core](#js-core)

## В чём разница между классом в ES6 и функцией-конструктором в ES5?

<details> 
  <summary>Правильный ответ</summary>

```javascript
// ES5 функция-конструктор

function Person(name) {
  this.name = name;
}

// ES6 класс

class Person {
  constructor(name) {
    this.name = name;
  }
}
```

Основное отличие в конструкторе возникает при использовании наследования. Если мы хотим создать класс `Student` (который будет являться подклассом класса `Person`) и добавить поле `studentId`, то в дополнение к вышеописанному мы должны сделать следующее:

```javascript
// ES5 функция-конструктор

function Student(name, studentId) {
  // Вызов конструктора суперкласса для инициализации производных от суперкласса членов.

  Person.call(this, name);

  // Инициализация собственных членов подкласса.

  this.studentId = studentId;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// ES6 класс

class Student extends Person {
  constructor (name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```

Наследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое.

</details>

[Вернуться в меню JS Core](#js-core)

## Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?

<details> 
  <summary>Правильный ответ</summary>

Преимуществом стрелочных функций является упрощение синтаксиса, необходимого для создания функций, без необходимости использования ключевого слова `function`. `this` внутри стрелочных функций также привязано к замыкающей области видимости, в отличие от обычных функций, где `this` определяется контекстом, в котором они вызываются. Лексически привязанное `this` полезно при вызове callback-функций, особенно в компонентах React.

</details>

[Вернуться в меню JS Core](#js-core)

## Дайте определение функции высшего порядка.

<details> 
  <summary>Правильный ответ</summary>

Функция высшего порядка — это любая функция, которая принимает одну или несколько функций в качестве аргументов, которые она использует для работы с данными, и/или возвращает функцию в качестве результата.  
Классическим примером является метод `map`, который принимает массив и функцию в качестве аргументов. Затем `map` использует эту функцию для преобразования каждого элемента в массиве, возвращая новый массив с преобразованными данными. Другими популярными примерами в JS являются `forEach`, `filter` и `reduce`.

</details> 

[Вернуться в меню JS Core](#js-core)

## Можете ли вы привести пример деструктуризации объекта или массива?

<details> 
  <summary>Правильный ответ</summary>

Деструктуризация - это выражение, доступное в ES6, которое предоставяет краткий и удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные.

**Деструктуризация массива**
```javascript
const rgb = [255, 200, 0]

const [red, green ,blue] = rgb;

console.log(`R: ${red}, G: ${green}, B: ${blue}`);
```

**Деструктуризация объекта**
```javascript
const student = {
  firstname: 'Glad',
  lastname: 'Chinda',
  country: 'Nigeria'
}

const { firstname, lastname, country } = student;

console.log(firstname, lastname, country); // Glad Chinda Nigeria
```

</details>

[Вернуться в меню JS Core](#js-core)

## Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?

<details> 
  <summary>Правильный ответ</summary>

```javascript
var person = { name: 'Tyler', age: 28};

console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);
```

</details>

[Вернуться в меню JS Core](#js-core)

## В чём преимущества использования spread оператора, чем он отличается от rest оператора?

<details> 
  <summary>Правильный ответ</summary>
  
**Spread** оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к `Object.create`, `slice` или функции библиотеки.

```javascript
function putSmthgInAnyArray(arr) {
  return [...arr, 'Smthg'];
}

const result = putSmthgInAnyArray([1, 2, 3]); // [1, 2, 3, 'Smthg'];

const person = {
  name: 'Todd',
  age: 29
};

const copyOfTodd = { ...person };
```

**Rest** оператор синтаксиса ES6 позволяет в сокращённом виде указывать неопределённое количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен spread оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов.

```javascript
function addFiveToABunchOfNumbers(...numbers) {
 return numbers.map(x => x + 5);
}

 const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9); // [9, 10, 11, 12, 13, 14]

 const [a, b, ...rest] = [1, 2, 3, 4]; // a:1, b:2, rest:[3, 4]

 const { e, f, ...others } = {
   e: 1,
   f: 2,
   g: 3,
   h: 4,
 }; // e:1, f: 2, others: { g:3, h:4 }
```  

</details>

[Вернуться в меню JS Core](#js-core)

## Каким образом можно обмениваться кодом между файлами?

<details> 
  <summary>Правильный ответ</summary>

Это зависит от среды выполнения JavaScript.

На клиенте (в среде барузера), пока переменные/функции объявлены в глобальной области видимости (window), все скрипты могут на них ссылаться. В качестве альтернативы, используйте Asynchronous Module Definition (AMD) через RequireJS для модульного подхода.

На сервере (Node.js) обычно используется CommonJS. Каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту `module.exports`.

ES2015 позволяет использовать модульный синтаксис, который призван заменить как AMD, так и CommonJS. В конечном итоге он будет поддерживаться как в браузере, так и в Node.

</details>

[Вернуться в меню JS Core](#js-core)

## В чем разница между async и defer?

<details> 
  <summary>Правильный ответ</summary>

Специальные атрибуты `async` и `defer` используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.  
Разница между `async` и `defer`: атрибут `defer` сохраняет относительную последовательность скриптов, а `async` – нет. Кроме того, `defer` всегда ждёт, пока весь HTML-документ будет готов, а `async` – нет.

</details>

[Вернуться в меню JS Core](#js-core)